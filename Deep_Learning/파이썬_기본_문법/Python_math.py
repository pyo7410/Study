#!/usr/bin/env python
# coding: utf-8

# In[1]:


# 시그마(Σ )

# numpy의 sum 함수를 이용하면 쉽게 구현이 가능하다.

import numpy as np

a = np.array([1, 2, 3, 4, 5])
print(np.sum(a))

# a와 b의 각 원소를 곱하고 sum 함수로 합산
a = np.array([2, 1, 2, 1, 2])
b = np.array([1, 2, 1, 2, 1])

print(np.sum(a * b))

# 자연상수(e)
# e = 2.718281828459045235360287471352...
# y = e^x 혹은 y = exp(x)
# 미분을 해도 자연상수 e는 변하지 않는다.

# numpy의 exp 함수를 이용하면 쉽게 구할 수 있다.
# exp 함수는 자연상수 e의 거듭제곱을 반환하는 함수이다.
# np.e 로도 구할 수 있다.

def get_exp(x):
    return np.exp(x)

print(get_exp(1))

# 자연로그(log)
# y = e^x 양변에 자연로그를 취하면 logy = x 가 된다.

# numpy의 log 함수를 이용하면 쉽게 구할 수 있다.

def get_log(x):
    return np.log(x)

print(get_log(2))


# In[12]:


# 선형대수

# 스칼라
# 파이썬에서 다루는 통상적인 수치는 스칼라를 의미
# e.g. a = 1, b = 1.2, c = -0.23, d = 1.2e5

# 벡터
# 스칼라를 직선 위에 나열해 놓은 것
# 벡터는 넘파이의 1차원 배열을 이용해 생성할 수 있다.
a = np.array([1, 2 ,3])
b = np.array([-2.3, 0.25, -1.2, 1.8, 0.41])

# 행렬
#   0.12  -0.34  1.3    0.81
#  -1.4    0.25  0.69  -0.41
#   0.25  -1.5  -0.15   1.1
# 수평 방향의 스칼라를 행 
# (e.g. 1행 : 0.12 -0.34 1.3 0.81, 2행 : -1.4 0.25 0.69 -0.41, 3행 : 0.25 -1.5 -0.15 1.1)
# 수직 방향의 스칼라를 열
# (e.g. 1열 : 0.12 -1.4 0.25, 2열 : -0.34 1.3 0.81, 3열 : 1.3 0.69 -0.15, 4열 : 0.81 -0.41 1.1)
# numpy의 2차원 배열을 이용하면 행렬을 쉽게 표현 가능
a = np.array([[1, 2, 3],
             [4, 5, 6]])
b = np.array([[0.21, 0.14],
             [-1.3, 0.81],
             [0.12, -2.1]])

# 텐서
# 스칼라를 여러 개의 차원으로 나열한 것으로 스칼라와 벡터, 행렬을 포함한다.
# 스칼라에는 첨자가 없으므로 0차원 텐서, 벡터에는 첨자가 1개이므로 1차원 텐서, 행렬은 첨자가 2개 이므로 2차원 텐서가 된다.
# 더 높은 차원의 텐서도 존재한다.
# numpy로 쉽게 표현 가능
a = np.array([[[0, 1, 2, 3],
               [2, 3, 4, 5],
               [4, 5, 6, 7]],
             
              [[1, 2, 3, 4],
               [3, 4, 5, 6],
               [5, 6, 7, 8]]]) # (2, 3, 4) 3차원 텐서

# reshape 메소드를 사용하여 텐서의 형태를 자유롭게 변경이 가능하다.
b = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]) # 1차원 텐서(벡터)
b = b.reshape(4, 6) # 2차원 텐서(행렬)
print(b)

b = b.reshape(2, 3, 4) # 3차원 텐서
print(b)

b = b.reshape(2, 2, 3, 2) # 4차원 텐서
print(b)

# 텐서의 형태는 변화해도 벡터의 원소의 수는 변하지 않는다 (24개)

# 텐서도 transpose가 가능하다.
c = np.array([[[1, 2, 3 ,4],
               [2, 0, 0, 0],
               [3, 0, 0, 0]],
             
              [[2, 0, 0, 0],
               [0, 0, 0, 0],
               [0, 0, 0, 0]]])

c = c.transpose(0, 2, 1) # 0번 축을 0번으로, 1번 축을 2번으로, 2번축을 1번으로

print(c)

c = c.transpose(2, 0, 1) # 맨 뒷부분의 차원을 가장 앞으로 이동
print(c)

c = c.transpose(1, 0, 2) # 다시 transpose를 하기 이전으로
print(c)


# In[21]:


# 행렬과 스칼라의 연산
# 곱셈이외에도 덧셈, 뺄셈, 나눗셈에 대해서도 가능하다.
c = 2
a = np.array([[0, 1, 2],
              [3, 4, 5],
              [6, 7, 8]])
print(c * a)

# 각 원소간의 곱셈
# 행렬 원소간의 곱셈을 아다마르 곱(Hadamard product)라고 부른다.
# 각 원소끼리 곱하려면 행렬의 크기가 같아야한다.
# 곱셈이외에도 덧셈, 뺄셈, 나눗셈에 대해서도 가능하다. 
a = np.array([[0, 1, 2],
              [3, 4, 5],
              [6, 7, 8]])
b = np.array([[0, 1, 2],
              [2, 0, 1],
              [1, 2, 0]])
print(a * b)
print(a + b)
print(a - b)
print(a / (b + 1)) # 1을 더해 0으로 나누는 것을 방지
print(a % (b + 1)) # 1을 더해 0으로 나누는 것을 방지

# 행렬 곱
# (x, m), (m, y) 처럼 m이 같아야지 행렬곱이 가능하다.
# 행렬곱의 결과는 (x, y)가 된다.
# numpy의 dot 함수를 이용하면 쉽게 구할 수 있다.
a = np.array([[0, 1, 2],
              [1, 2, 3]])
b = np.array([[2, 1],
              [2, 1],
              [2, 1]])
print(np.dot(a, b))


# dot 함수는 행렬과 벡터(1차원 배열)의 곱셈도 계산할 수 있다.
a = np.array([1, 2, 3])
b = np.array([[1, 2],
              [1, 2],
              [1, 2]])
print(np.dot(a, b))

# 행렬 전치
# 행렬을 전치시키면 행과 열이 바뀐다.
# A의 전치행렬을 A^T 로 표기
# numpy에서는 행렬 이름뒤에 .T를 붙이면 전치가 된다.
a = np.array([[1, 2, 3],
              [4, 5, 6]])
print(a.T)
# 전치를 사용하면 a = (l, m), b = (n, m)과 같이 곱이 불가능한 행렬을
# a = (l, m), b^T = (m, n) 형태로 변환 시킬 수 있어 곱이 가능하게 된다.
a = np.array([[0, 1, 2],
              [1, 2, 3]])
b = np.array([[0, 1, 2],
              [1, 2, 3]])

#print(np.dot(a, b)) # 실행하면 오류가 나온다
print(np.dot(a, b.T))

# 전치는 transpose 함수로도 실행 할 수 있다 (e. g. transpose(1, 0))
# 차원 수가 높은 텐서의 축 변경은 transpose를 이용한다.

# 미분법은 114p 참고


# In[31]:


# 정규분포
# 가우스 분포라고도 부른다.
# 그래프에서 가로축은 특정 값을, 세로축은 그 값의 빈도와 확률을 표시
# μ(뮤)는 평균을, σ(시그마)는 표준편차로서 데이터가 평균을 중심으로 얼마나 퍼져있는지를 표현하는 척도이다.
# 평균과 표준편차는 numpy의 average와 std 함수를 이용해 간단하게 구현 가능
a = np.array([1, 2, 3, 4, 5])

print("평균 : ", np.average(a))
print("표준편차 : ", np.std(a))

# numpy의 random.normal 함수로 정규분포를 따르는 난수를 생성하고 matplotlib의 hist 함수로 히스토그램을 표현
get_ipython().run_line_magic('matplotlib', 'inline')
import matplotlib.pyplot as plt

x = np.random.normal(50, 10, 10000) # 난수 생성 (평균 50, 표준편차 10, 10000개 생성)

plt.hist(x, bins = 50) # 히스토그램 표시(50은 막대의 수)
plt.show()

# x의 평균과 표준편차
print(np.average(x))
print(np.std(x))


# In[ ]:





# In[ ]:




